# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gXAs9UTXWzLqc8-iC85Q2Ljk8vd4nilg
"""


import streamlit as st
from sklearn.preprocessing import LabelEncoder
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns 
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import mean_squared_error, accuracy_score, precision_score

def load_data():
    merged_df = pd.read_csv('merged_df.csv')
    return merged_df

def preprocess_data(merged_df):
    merged_df.fillna(0, inplace=True)

    # Label encoding for object columns
    object_cols = merged_df.select_dtypes(include=['object']).columns
    le = LabelEncoder()
    for col in object_cols:
        if merged_df[col].dtype == 'object':
            try:
                merged_df[col] = le.fit_transform(merged_df[col])
            except Exception as e:
                print(f"Error encoding column {col}: {e}")

    return merged_df

def visualize_data(merged_df):
    st.subheader('Book Ratings Distribution')
    plt.figure(figsize=(10, 5))
    sns.histplot(merged_df['Book-Rating'], bins=10, kde=True)
    plt.title('Distribution of Book Ratings')
    plt.xlabel('Rating')
    plt.ylabel('Frequency')
    st.pyplot(plt)

    st.subheader('Top Rated Books')
    top_books = merged_df.groupby('Book-Title')['Book-Rating'].mean().sort_values(ascending=False).head(10)
    plt.figure(figsize=(10, 5))
    top_books.plot(kind='bar', color='skyblue')
    plt.title('Top 10 Rated Books')
    plt.xlabel('Book Title')
    plt.ylabel('Average Rating')
    plt.xticks(rotation=45)
    st.pyplot(plt)

    # Additional visualizations
    st.subheader('Number of Ratings per Book')
    ratings_count = merged_df['Book-Title'].value_counts().head(10)
    plt.figure(figsize=(10, 5))
    ratings_count.plot(kind='bar', color='orange')
    plt.title('Top 10 Books by Number of Ratings')
    plt.xlabel('Book Title')
    plt.ylabel('Number of Ratings')
    plt.xticks(rotation=45)
    st.pyplot(plt)

    # Show dataset information and description
    st.subheader('Dataset Information')
    st.write(merged_df.info())
    st.subheader('Dataset Description')
    st.write(merged_df.describe())

def get_recommendations_collaborative(user_id, cosine_sim_df, user_book_ratings):
    if user_id not in cosine_sim_df.index:
        st.error(f"User ID {user_id} not found in the data.")
        return []
    similar_users = cosine_sim_df.loc[user_id].sort_values(ascending=False)[1:11] 
    recommendations = []
    for similar_user in similar_users.index:
        rated_books = user_book_ratings.loc[similar_user][user_book_ratings.loc[similar_user] > 0]
        for book_isbn in rated_books.index:
            if user_book_ratings.loc[user_id, book_isbn] == 0:
                recommendations.append(book_isbn)
    return recommendations[:10]

def get_recommendations_content_based(book_index, cosine_sim_content_df):
    similar_books = cosine_sim_content_df[book_index].sort_values(ascending=False)[1:11]
    return similar_books.index.tolist()

def get_hybrid_recommendations(user_id, book_index, cosine_sim_df, cosine_sim_content_df, user_book_ratings):
    collaborative_recs = get_recommendations_collaborative(user_id, cosine_sim_df, user_book_ratings)
    content_based_recs = get_recommendations_content_based(book_index, cosine_sim_content_df)
    hybrid_recommendations = list(set(collaborative_recs + content_based_recs))
    return hybrid_recommendations[:10]

def plot_recommendation_results(recommendations, merged_df):
    recommended_books = merged_df[merged_df['ISBN'].isin(recommendations)]
    plt.figure(figsize=(10, 5))
    sns.barplot(data=recommended_books, x='Book-Title', y='Book-Rating', palette='viridis')
    plt.title('Book Recommendations with Ratings')
    plt.xlabel('Book Title')
    plt.ylabel('Book Rating')
    plt.xticks(rotation=45)
    st.pyplot(plt)

    # Year of publication
    plt.figure(figsize=(10, 5))
    sns.countplot(data=recommended_books, x='Year-Of-Publication', palette='Blues')
    plt.title('Year of Publication of Recommended Books')
    plt.xlabel('Year of Publication')
    plt.ylabel('Count of Recommendations')
    st.pyplot(plt)

    # Age Distribution of Users
    plt.figure(figsize=(10, 5))
    sns.histplot(recommended_books['Age'], bins=10, kde=True)
    plt.title('Age Distribution of Users who Rated Recommended Books')
    plt.xlabel('Age')
    plt.ylabel('Frequency')
    st.pyplot(plt)

def main():
    # Load and preprocess data
    merged_df = load_data()
    merged_df = preprocess_data(merged_df)
    visualize_data(merged_df)

    # Create a subset of the merged_df for faster processing
    merged_df_subset = merged_df.iloc[:10000]

    # Collaborative Filtering using Cosine Similarity
    user_book_ratings = merged_df_subset.pivot_table(index='User-ID', columns='ISBN', values='Book-Rating').fillna(0)
    cosine_sim = cosine_similarity(user_book_ratings)
    cosine_sim_df = pd.DataFrame(cosine_sim, index=user_book_ratings.index, columns=user_book_ratings.index)

    # Content-Based Filtering
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(merged_df_subset['Book-Title'].astype(str))
    cosine_sim_content = cosine_similarity(tfidf_matrix, tfidf_matrix)
    cosine_sim_content_df = pd.DataFrame(cosine_sim_content, index=merged_df_subset.index, columns=merged_df_subset.index)

    # User input for recommendations
    st.title("Book Recommendation System")
    user_id_to_recommend = st.selectbox("Select User ID", merged_df_subset['User-ID'].unique())
    book_index_to_recommend = st.number_input("Enter Book Index (0-9999)", min_value=0, max_value=9999, value=0)

    if st.button("Get Recommendations"):
        hybrid_recommendations = get_hybrid_recommendations(user_id_to_recommend, book_index_to_recommend, cosine_sim_df, cosine_sim_content_df, user_book_ratings)
        st.write("Hybrid Filtering Recommendations:")
        st.write(hybrid_recommendations)

        # Plotting the recommendation results
        plot_recommendation_results(hybrid_recommendations, merged_df)

    # Model evaluation (optional, if you want to display MSE, Accuracy, Precision)
    X = merged_df_subset.drop('Book-Rating', axis=1)
    y = merged_df_subset['Book-Rating']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    def predict_rating(user_id, book_isbn):
        average_rating = merged_df_subset[merged_df_subset['ISBN'] == book_isbn]['Book-Rating'].mean()
        return average_rating if not np.isnan(average_rating) else 0

    y_pred = []
    for index, row in X_test.iterrows():
        user_id = row['User-ID']
        book_isbn = row['ISBN']
        predicted_rating = predict_rating(user_id, book_isbn)
        y_pred.append(predicted_rating)

    mse = mean_squared_error(y_test, y_pred)
    st.write(f"Mean Squared Error (MSE): {mse}")

    y_test_binary = [1 if rating >= 4 else 0 for rating in y_test]
    y_pred_binary = [1 if rating >= 4 else 0 for rating in y_pred]

    accuracy = accuracy_score(y_test_binary, y_pred_binary)
    st.write(f"Accuracy: {accuracy}")

    precision = precision_score(y_test_binary, y_pred_binary, zero_division=0)
    st.write(f"Precision: {precision}")

if __name__ == "__main__":
    main() 



